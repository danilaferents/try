<!DOCTYPE html>
<html lang="en">
<head>
  <title>Berlin Trams</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    html, body { height: 100%; }

    body {
      margin: 0;
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      position: relative;
      z-index: 0;
      background: #d5d5d5;

      /* dynamic inset so split panes never start under control panel */
      --hudTopInset: 10px;
    }

    body::before {
      content: "";
      position: fixed;
      inset: 0;
      z-index: 0;
      pointer-events: none;
      background: rgba(0,0,0,0.06);
    }

    body::after {
      content: "";
      position: fixed;
      inset: 0;
      z-index: 1;
      pointer-events: none;
      background-image: url("assets/neslogo.png");
      background-repeat: repeat;
      background-size: 90px 90px;
      opacity: 0.08;
    }

    #container {
      position: fixed;
      inset: 0;
      z-index: 2;
    }

    /* HUD panels */
    #setupHUD {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 30;          /* ALWAYS above */
      pointer-events: none;
    }

    /* Topology HUD (default bottom-right) */
    #topologyHUD{
      position:absolute;
      right:10px;
      bottom:10px;
      z-index:10;
      pointer-events:none;
    }

    /* Snapshots HUD: LEFT, grows UP and RIGHT */
    #snapshotsHUD{
      position:absolute;
      left:10px;
      bottom:10px;
      z-index:10;
      pointer-events:none;
    }

    .panel {
      pointer-events: auto;
      width: 450px;
      background: rgba(255,255,255,0.92);
      border-radius: 10px;
      padding: 10px 12px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.10);
      border: 1px solid rgba(0,0,0,0.08);
    }

    .panelHeader {
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      margin-bottom: 8px;
    }

    .panelTitle { font-weight: 800; font-size: 12px; letter-spacing: 0.2px; }
    .hr { height: 1px; background: rgba(0,0,0,0.12); margin: 10px 0; }
    .small { font-size: 11px; opacity: 0.8; }

    /* Topology box */
    #topologyBox{
      height:400px;
      border-radius:8px;
      border:1px dashed rgba(0,0,0,0.25);
      background: linear-gradient(180deg, rgba(0,0,0,0.02), rgba(0,0,0,0.00));
      overflow:hidden;
    }
    #topologyPanel{
      width: 600px;
    }

    /* snapshots panel sizing */
    #snapshotsPanel{
      width: 800px;
    }
    #snapshotsBox{
      max-height: calc(100vh - 220px);
      overflow:auto;
      padding-right: 6px;
    }

    .shotImgsRow{
      display: flex;
      gap: 16px;
      align-items: stretch;
    }

    /* each graph fills half */
    .shotImgsRow .shotImg{
      flex: 1 1 50%;
      width: 50%;
      max-width: 50%;
      border-radius: 8px;
      background: white; /* üîë ensures same look */
    }

    /* One snapshot row holding 2 tiles */
    .shotRow{
      display: flex;
      gap: 14px;
      margin-top: 10px;
    }

    /* Each graph becomes its own white tile */
    .shotTile{
      position: relative;
      flex: 1 1 0;
      min-width: 0;
      background: rgba(255,255,255,0.92);
      border: 1px solid rgba(0,0,0,0.10);
      border-radius: 12px;
      padding: 10px;
      box-shadow: 0 10px 22px rgba(0,0,0,0.08);
    }

    /* Image inside tile */
    .shotTile .shotImg{
      width: 100%;
      display: block;
      border-radius: 10px;
      border: 1px dashed rgba(0,0,0,0.20);
      background: white;
    }

    /* Tile header */
    .shotTileTitle{
      font-weight: 900;
      font-size: 12px;
      margin-bottom: 6px;
      padding-right: 30px; /* space for X */
    }

    /* Per-tile delete X */
    .shotTileDel{
      position: absolute;
      top: 10px;
      right: 10px;
      width: 22px;
      height: 22px;
      border-radius: 8px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 900;
      line-height: 1;
      background: rgba(255,255,255,0.92);
      border: 1px solid rgba(0,0,0,0.14);
      box-shadow: 0 8px 16px rgba(0,0,0,0.10);
      cursor: pointer;
    }
    .shotTileDel:hover{
      background: rgba(255,255,255,0.98);
      border-color: rgba(0,0,0,0.22);
      transform: translateY(-1px);
    }

    /* stack on narrow widths */
    @media (max-width: 760px){
      .shotRow{ flex-direction: column; }
    }

    /* Optional: stack on small screens */
    @media (max-width: 560px){
      .shotImgsRow{ flex-direction: column; }
    }

    /* Graph box (inside Snapshots panel bottom) */
    #graphBox {
      height: 250px;
      border-radius: 8px;
      border: 1px dashed rgba(0,0,0,0.25);
      background: linear-gradient(180deg, rgba(0,0,0,0.02), rgba(0,0,0,0.00));
      overflow: hidden;
    }

    /* Deployment latency graph box */
    #deployGraphBox{
      height: 250px;
      border-radius: 8px;
      border: 1px dashed rgba(0,0,0,0.25);
      background: linear-gradient(180deg, rgba(0,0,0,0.02), rgba(0,0,0,0.00));
      overflow: hidden;
    }

    /* NEW: live graphs wrapper (hidden when stopped) */
    #liveGraphsSection.hidden { display:none; }

    /* Form rows */
    .fieldRow {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-top: 8px;
    }
    .fieldRow label { font-size: 12px; }
    select {
      font-size: 12px;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid rgba(0,0,0,0.15);
      background: white;
      min-width: 150px;
    }

    button {
      font-size: 12px;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid rgba(0,0,0,0.15);
      background: white;
      cursor: pointer;
    }
    button:hover { background: rgba(255,255,255,0.92); }
    button:disabled { opacity: 0.5; cursor: not-allowed; }

    /* Scenario buttons */
    .tabsCol{
      pointer-events:auto;
      display:flex;
      flex-direction:column;
      gap:8px;
      margin-top: 2px;
    }
    .scenarioBtn{
      font-size:12px;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(0,0,0,0.18);
      background: rgba(255,255,255,0.55);
      cursor:pointer;
      text-align:center;
      font-weight: 800;
      letter-spacing: 0.2px;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.35);
      transition: transform 120ms ease, box-shadow 120ms ease, background 120ms ease, border-color 120ms ease;
    }
    .scenarioBtn:hover{ transform: translateY(-1px); }
    .scenarioBtn.active{
      background: rgba(255,255,255,0.78);
      border-color: rgba(0,0,0,0.28);
      box-shadow:
        0 12px 26px rgba(0,0,0,0.12),
        inset 0 0 0 2px rgba(255,255,255,0.55);
    }
    .scenarioBtn .dot{
      display:inline-block;
      width:10px;
      height:10px;
      border-radius:999px;
      margin-right:8px;
      vertical-align:middle;
      background: rgba(0,0,0,0.18);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,0.35);
    }
    .scenarioBtn.active .dot{
      background: rgba(36,60,255,0.85);
    }

    /* Control panel hide/show */
    #setupHUD.hidden { display:none; }
    #showControlBtn{
      position:absolute;
      top:10px;
      left:10px;
      z-index: 31;
      pointer-events:auto;
      display:none;
    }
    #showControlBtn.visible{ display:block; }

    /* Config collapse button style */
    .pillBtn{
      width:100%;
      text-align:center;
      font-weight: 900;
      border-radius: 999px;
      padding: 10px 12px;
      background: rgba(255,255,255,0.75);
    }
    .pillBtn.active{
      background: white;
      box-shadow: 0 10px 22px rgba(0,0,0,0.10);
      border-color: rgba(0,0,0,0.28);
    }

    /* Snapshots cards + delete X */
    .shot{
      position: relative;
      border:1px solid rgba(0,0,0,0.10);
      border-radius:10px;
      background: rgba(255,255,255,0.7);
      padding:8px;
      margin-top:10px;
    }
    .shotTitle{
      font-weight:800;
      font-size:12px;
      margin-bottom:6px;
      line-height:1.2;
      padding-right: 26px;
    }
    .shotMeta{
      font-size:11px;
      opacity:0.8;
      margin-bottom:8px;
    }
    .shotImg{
      width:100%;
      border-radius:8px;
      border:1px dashed rgba(0,0,0,0.20);
      display:block;
    }
    .shotDel{
      position:absolute;
      top:8px;
      right:8px;
      width:22px;
      height:22px;
      border-radius:8px;
      padding:0;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:900;
      line-height:1;
      background: rgba(255,255,255,0.85);
      border: 1px solid rgba(0,0,0,0.14);
      box-shadow: 0 8px 16px rgba(0,0,0,0.10);
      cursor:pointer;
    }
    .shotDel:hover{
      background: rgba(255,255,255,0.98);
      border-color: rgba(0,0,0,0.22);
      transform: translateY(-1px);
    }

    /* Bottom-left Train UI (unchanged) */
    #ui {
      position: absolute;
      bottom: 10px;
      left: 10px;
      padding: 10px 12px;
      background: rgba(255,255,255,0.92);
      border-radius: 8px;
      font-size: 12px;
      z-index: 10;
      line-height: 1.35;
      min-width: 320px;
    }
    #ui .uiBody { margin-top: 8px; }
    #ui.collapsed .uiBody { display: none; }
    .row { margin-top: 8px; display: flex; align-items: center; gap: 8px; }
    .label { display: inline-block; width: 92px; }
    .val { display: inline-block; width: 60px; text-align: right; }
    input[type="range"] { width: 180px; }

    /* ---------------------------------------------------
       SPLIT LAYOUT (when map is OFF)
    --------------------------------------------------- */
    body.splitMode #topologyHUD,
    body.splitMode #snapshotsHUD{
      position: fixed;
      top: var(--hudTopInset);
      bottom: 10px;
      z-index: 9;
    }

    body.splitMode #snapshotsHUD{
      left: 10px;
      right: auto;
      width: calc(50vw - 15px);
    }

    body.splitMode #topologyHUD{
      right: 10px;
      left: auto;
      width: calc(50vw - 15px);
      bottom: 10px;
    }

    body.splitMode #snapshotsPanel,
    body.splitMode #topologyPanel{
      width: 100%;
      height: calc(100vh - 20px);
      display: flex;
      flex-direction: column;
    }

    body.splitMode #topologyBox{
      height: auto;
      flex: 1;
    }

    body.splitMode #snapshotsBox{
      max-height: none;
      flex: 1;
      overflow: auto;
    }

    body.splitMode #graphBox{
      height: 320px;
    }

    body.splitMode #deployGraphBox{
      height: 280px;
    }

    /* ---------------------------------------------------
       NO OVERLAP (map ON + topo+shots ON)
    --------------------------------------------------- */
    body.noOverlapHUD #topologyHUD{
      top: 10px;
      bottom: auto;
      right: 10px;
    }
    body.noOverlapHUD #snapshotsHUD{
      left: 10px;
      bottom: 10px;
    }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>

<body>
<div id="container"></div>

<button id="showControlBtn" type="button" class="">Show control panel</button>

<div id="setupHUD">
  <div class="panel" id="setupPanel">
    <div class="panelHeader" style="align-items:center;">
      <div class="panelTitle">Control panel</div>
      <button id="hideControlBtn" type="button" title="Hide panel">Hide</button>
    </div>

    <button id="configToggleBtn" class="pillBtn active" type="button">Configuration</button>

    <div id="configFields" style="margin-top:10px;">
      <div class="fieldRow">
        <label for="totalNodes">Number of nodes</label>
        <select id="totalNodes"></select>
      </div>

      <div class="fieldRow">
        <label for="mobileNodes">Number of mobile nodes</label>
        <select id="mobileNodes"></select>
      </div>

      <div class="fieldRow">
        <label for="cameraMode">Rate of topology changes</label>
        <select id="cameraMode">
          <option value="500">500ms</option>
          <option value="1000" selected>1s</option>
          <option value="2000">2s</option>
          <option value="4000">4s</option>
        </select>
      </div>

      <div class="fieldRow">
        <label for="reconfigMode">Reconfiguration</label>
        <select id="reconfigMode">
          <option value="holistic" selected>Holistic</option>
          <option value="incremental">Incremental</option>
        </select>
      </div>

      <div class="fieldRow">
        <label for="queryMode">Query</label>
        <select id="queryMode">
          <option value="stateful" selected>Stateful</option>
          <option value="stateless">Stateless</option>
        </select>
      </div>

      <div class="fieldRow">
        <button id="applyConfigBtn" type="button">Apply (Start)</button>
        <button id="stopBtn" type="button" disabled>Stop</button>
        <button id="resetViewBtn" type="button">Reset view</button>
      </div>

      <div class="small" id="pendingHint" style="margin-top:6px; opacity:0.7;">
        Changes apply only when you click <b>Apply</b>.
      </div>
    </div>

    <div class="hr"></div>

    <div class="panelTitle" style="margin-bottom:6px;">Scenarios</div>
    <div class="tabsCol" role="tablist" aria-label="Scenario">
      <button id="scenarioViz" class="scenarioBtn" type="button"><span class="dot"></span>Visualization (Map)</button>
      <button id="scenarioTopo" class="scenarioBtn" type="button"><span class="dot"></span>Topology graph</button>
      <button id="scenarioShots" class="scenarioBtn" type="button"><span class="dot"></span>Snapshots (Latency graph)</button>
    </div>
  </div>
</div>

<div id="topologyHUD" style="display:none;">
  <div class="panel" id="topologyPanel">
    <div class="panelHeader" style="align-items:center;">
      <div class="panelTitle">Topology graph</div>
    </div>
    <div id="topologyBox">
      <canvas id="topologyCanvas" style="width:100%; height:100%; border-radius:8px;"></canvas>
    </div>
  </div>
</div>

<div id="snapshotsHUD" style="display:none;">
  <div class="panel" id="snapshotsPanel">

    <!-- UPDATED HEADER: config on top, run state on right -->
    <div class="panelHeader">
      <div style="display:flex; flex-direction:column; gap:2px;">
        <div class="small" id="configTitle" style="opacity:0.85;">‚Äî</div>
        <div class="panelTitle">Snapshots</div>
      </div>
      <div class="small" id="runStateTitle" style="text-align:right; opacity:0.75;">idle</div>
    </div>

    <div id="snapshotsBox"></div>

    <!-- WRAP BOTH GRAPHS so we can hide on stop -->
    <div id="liveGraphsSection">
      <div class="hr"></div>

      <div class="small" style="opacity:0.75; margin-bottom:8px;">
        Live latency graph (captured into snapshots on Stop)
      </div>

      <div id="graphBox">
        <canvas id="graphCanvas" width="420" height="250" style="width:100%; height:100%; border-radius:8px;"></canvas>
      </div>

      <div class="hr"></div>

      <div class="panelHeader" style="margin-bottom:6px; align-items:center;">
        <div class="panelTitle">Deployment latency</div>
        <div class="small" id="deployGraphTitle" style="text-align:right;">‚Äî</div>
      </div>

      <div class="small" style="opacity:0.75; margin-bottom:8px;">
        Static (placeholder) ‚Äî captured into snapshots on Stop
      </div>

      <div id="deployGraphBox">
        <canvas id="deployCanvas" width="420" height="250" style="width:100%; height:100%; border-radius:8px;"></canvas>
      </div>
    </div>

  </div>
</div>

<div id="ui" class="collapsed">
  <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
    <div style="display:flex; align-items:center; gap:8px;">
      <b>Train settings</b>
      <button id="toggleUIBtn" type="button" title="Hide/Show panel">Hide</button>
    </div>
  </div>

  <div class="uiBody">
    <div class="row">
      <span class="label">Trains</span>
      <input id="trainCount" type="range" min="1" max="8" value="2" disabled />
      <span id="trainCountVal" class="val">2</span>
    </div>

    <div class="row">
      <span class="label">Speed</span>
      <input id="speed" type="range" min="0.000" max="0.1" step="0.001" value="0.03" />
      <span id="speedVal" class="val">0.030</span>
    </div>
  </div>
</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

/**
 * DEBUG TOGGLES
 */
const DEBUG = {
  showTrainSettings: false,
};

const MODEL_URL = 'models/gltf/Berlin.glb';
const MAX_PIXEL_RATIO = 1.5;

const INIT = {
  target: new THREE.Vector3(214, 0, -5000),
  modelPos: new THREE.Vector3(734, -3291, -419),
  cam: { dist: 7800, yaw: 0, elev: -43 }
};

// -----------------------------------------------------
// THREE
// -----------------------------------------------------
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setPixelRatio(Math.min(devicePixelRatio, MAX_PIXEL_RATIO));
renderer.setSize(innerWidth, innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
renderer.setClearColor(0x000000, 0);
document.getElementById('container').appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = null;

// overlay group in WORLD space
const overlayGroup = new THREE.Group();
scene.add(overlayGroup);

const camera = new THREE.PerspectiveCamera(45, innerWidth / innerHeight, 0.1, 300000);
camera.position.set(0, 600, 900);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.06;
controls.enablePan = true;
controls.screenSpacePanning = true;
controls.zoomSpeed = 1.0;
controls.panSpeed = 0.9;
controls.rotateSpeed = 0.7;
controls.minPolarAngle = 0.05;
controls.maxPolarAngle = Math.PI - 0.05;

scene.add(new THREE.HemisphereLight(0xffffff, 0x2a1a44, 1.8));
scene.add(new THREE.AmbientLight(0xffffff, 0.45));
const sun = new THREE.DirectionalLight(0xffffff, 1.25);
sun.position.set(2000, 4000, 1000);
scene.add(sun);

// -----------------------------------------------------
// REFS
// -----------------------------------------------------
const setupHUDEl = document.getElementById('setupHUD');
const hideControlBtn = document.getElementById('hideControlBtn');
const showControlBtn = document.getElementById('showControlBtn');

const totalNodesEl = document.getElementById('totalNodes');
const mobileNodesEl = document.getElementById('mobileNodes');
const cameraModeEl  = document.getElementById('cameraMode');
const reconfigModeEl = document.getElementById('reconfigMode');
const queryModeEl = document.getElementById('queryMode');

const applyConfigBtn = document.getElementById('applyConfigBtn');
const stopBtn = document.getElementById('stopBtn');
const resetViewBtn = document.getElementById('resetViewBtn');

const topologyHUDEl = document.getElementById('topologyHUD');
const snapshotsHUDEl = document.getElementById('snapshotsHUD');

const configToggleBtn = document.getElementById('configToggleBtn');
const configFieldsEl  = document.getElementById('configFields');

const scenarioVizBtn   = document.getElementById('scenarioViz');
const scenarioTopoBtn  = document.getElementById('scenarioTopo');
const scenarioShotsBtn = document.getElementById('scenarioShots');

const snapshotsBoxEl = document.getElementById('snapshotsBox');

const deployTitleEl = document.getElementById('deployGraphTitle');
const deployCanvas = document.getElementById('deployCanvas');
const dctx = deployCanvas?.getContext('2d');

/* NEW header bits */
const configTitleEl = document.getElementById('configTitle');
const runStateTitleEl = document.getElementById('runStateTitle');
const liveGraphsSectionEl = document.getElementById('liveGraphsSection');

function msToLabel(ms){
  if (ms >= 1000) return `${(ms/1000)}s`;
  return `${ms}ms`;
}

// -----------------------------------------------------
// CONTROL PANEL HIDE/SHOW + dynamic split top inset
// -----------------------------------------------------
function setControlPanelVisible(visible){
  if (!setupHUDEl || !showControlBtn) return;
  setupHUDEl.classList.toggle('hidden', !visible);
  showControlBtn.classList.toggle('visible', !visible);
}

function updateHudTopInset(){
  const isHidden = setupHUDEl?.classList.contains('hidden');
  if (isHidden) {
    document.body.style.setProperty('--hudTopInset', '10px');
    return;
  }

  const panel = document.getElementById('setupPanel');
  if (!panel) {
    document.body.style.setProperty('--hudTopInset', '10px');
    return;
  }

  const r = panel.getBoundingClientRect();
  const inset = Math.min(window.innerHeight - 20, Math.ceil(r.bottom + 10));
  document.body.style.setProperty('--hudTopInset', `${inset}px`);
}

hideControlBtn?.addEventListener('click', () => { setControlPanelVisible(false); updateHudTopInset(); });
showControlBtn?.addEventListener('click', () => { setControlPanelVisible(true);  updateHudTopInset(); });
setControlPanelVisible(true);
updateHudTopInset();

// -----------------------------------------------------
// CONFIG SELECTS (EVEN ONLY)
// -----------------------------------------------------
function fillSelectRangeEven(selectEl, min, max) {
  selectEl.innerHTML = '';
  const start = (min % 2 === 0) ? min : (min + 1);
  for (let v = start; v <= max; v += 2) {
    const opt = document.createElement('option');
    opt.value = String(v);
    opt.textContent = String(v);
    selectEl.appendChild(opt);
  }
}

function clampEven(v, min, max){
  v = Math.round(v);
  if (v % 2 !== 0) v += 1;
  v = Math.max(min, Math.min(max, v));
  if (v % 2 !== 0) v -= 1;
  return v;
}

// total nodes: even only
fillSelectRangeEven(totalNodesEl, 2, 16);
totalNodesEl.value = '8';

function rebuildMobileOptionsPreserveSelection(){
  const total = parseInt(totalNodesEl.value, 10);
  const maxMobile = Math.min(total, 8);
  const current = parseInt(mobileNodesEl.value || '4', 10);
  fillSelectRangeEven(mobileNodesEl, 2, maxMobile);
  const clamped = clampEven(current, 2, maxMobile);
  mobileNodesEl.value = String(clamped);
}
rebuildMobileOptionsPreserveSelection();
mobileNodesEl.value = '4';

cameraModeEl.value = '1000';
reconfigModeEl.value = 'holistic';
queryModeEl.value = 'stateful';

let activeConfig = {
  totalNodes: 8,
  mobileNodes: 4,
  topoChangeMs: 1000,
  reconfigMode: 'holistic',
  queryMode: 'stateful'
};

/* NEW: config title (above snapshots) */
function setConfigTitleFromActive(){
  const c = activeConfig;
  const fixed = Math.max(0, c.totalNodes);
  const base =
    `${c.mobileNodes} mobile / ${fixed} fixed/ ` +
    `${msToLabel(c.topoChangeMs)} / ${c.reconfigMode} / ${c.queryMode}`;
  if (configTitleEl) configTitleEl.textContent = base;
}

/* NEW: run state title (right side) */
function setRunStateLabel(text){
  if (runStateTitleEl) runStateTitleEl.textContent = text;
}

/* keep deploy title as configuration line */
function setDeployTitleFromActive(){
  const c = activeConfig;
  const fixed = Math.max(0, c.totalNodes);
  const base =
    `${c.mobileNodes} mobile / ${fixed} fixed` +
    `${msToLabel(c.topoChangeMs)} / ${c.reconfigMode} / ${c.queryMode}`;
  if (deployTitleEl) deployTitleEl.textContent = base;
}

function setLiveGraphsVisible(visible){
  if (!liveGraphsSectionEl) return;
  liveGraphsSectionEl.classList.toggle('hidden', !visible);
}

setConfigTitleFromActive();
setDeployTitleFromActive();
setRunStateLabel('idle');

totalNodesEl.addEventListener('change', () => {
  const total = clampEven(parseInt(totalNodesEl.value, 10) || 8, 2, 16);
  totalNodesEl.value = String(total);
  rebuildMobileOptionsPreserveSelection();
  updateHudTopInset();
  setConfigTitleFromActive();
  setDeployTitleFromActive();
});

mobileNodesEl.addEventListener('change', () => {
  const total = parseInt(totalNodesEl.value, 10);
  const maxMobile = Math.min(total, 8);
  const m = clampEven(parseInt(mobileNodesEl.value, 10) || 4, 2, maxMobile);
  mobileNodesEl.value = String(m);
  updateHudTopInset();
  setConfigTitleFromActive();
  setDeployTitleFromActive();
});

// -----------------------------------------------------
// CONFIG COLLAPSE (only fields)
// -----------------------------------------------------
let configOpen = true;
function setConfigOpen(open){
  configOpen = open;
  if (configFieldsEl) configFieldsEl.style.display = open ? 'block' : 'none';
  if (configToggleBtn) configToggleBtn.classList.toggle('active', open);
  updateHudTopInset();
}
configToggleBtn?.addEventListener('click', () => setConfigOpen(!configOpen));
setConfigOpen(true);

// -----------------------------------------------------
// EXPERIMENT STATE
// -----------------------------------------------------
let exp = {
  running: false,
  startMs: 0,
  stopMs: 0,
  tickTimer: null,
  points: [],
  maxPoints: 2500,
  lastTopoEventMs: 0,
  frozen: false,
  scrollAfterStop: false,
  holistic: {
    phase: 'idle',
    rampStartMs: 0,
    rampDurationMs: 10000,
    baseAtRampStart: 0,
    jumpTarget: 0,
  }
};

function nowMs(){ return performance.now(); }

function resetExperimentGraph(){
  exp.points = [];
  exp.frozen = false;
  exp.lastTopoEventMs = 0;
  exp.scrollAfterStop = false;

  exp.holistic.phase = 'idle';
  exp.holistic.rampStartMs = 0;
  exp.holistic.baseAtRampStart = 0;
  exp.holistic.jumpTarget = 0;
}

// -----------------------------------------------------
// STATE (model / trains)
// -----------------------------------------------------
let rootRef = null;
let pathCurve = null;

let rawTrainRef = null;
let trainMeshPrototype = null;

const trains = [];
const trainData = [];

let modelFixedQ = new THREE.Quaternion();
let pathMesh = null;

// -----------------------------------------------------
// TRAIN UI (DEBUG.showTrainSettings)
// -----------------------------------------------------
const uiEl = document.getElementById('ui');
function applyTrainUIVisibility() {
  if (!uiEl) return;
  uiEl.style.display = DEBUG.showTrainSettings ? 'block' : 'none';
}
applyTrainUIVisibility();

const trainCountEl = document.getElementById('trainCount');
const trainCountVal = document.getElementById('trainCountVal');
const speedEl = document.getElementById('speed');
const speedVal = document.getElementById('speedVal');
const toggleUIBtn = document.getElementById('toggleUIBtn');

if (DEBUG.showTrainSettings) {
  function syncToggleLabel() {
    toggleUIBtn.textContent = uiEl.classList.contains('collapsed') ? 'Show' : 'Hide';
  }
  syncToggleLabel();
  toggleUIBtn.addEventListener('click', () => {
    uiEl.classList.toggle('collapsed');
    syncToggleLabel();
  });
}

const settings = {
  trainCount: 2,
  speedUser: speedEl ? parseFloat(speedEl.value) : 0.03,
  speedActive: 0,
};

function syncUI() {
  if (!DEBUG.showTrainSettings) return;
  if (trainCountVal && trainCountEl) {
    trainCountVal.textContent = String(settings.trainCount);
    trainCountEl.value = String(settings.trainCount);
  }
  if (speedVal) speedVal.textContent = settings.speedUser.toFixed(3);
}
syncUI();

if (speedEl) {
  speedEl.addEventListener('input', () => {
    settings.speedUser = parseFloat(speedEl.value);
    syncUI();
    if (exp.running) settings.speedActive = settings.speedUser;
  });
}

// -----------------------------------------------------
// EDGE CENTERS + TRAIN->EDGE CONNECTIONS
// -----------------------------------------------------
const EDGE = {
  centers: [],
  height: 650,
  radius: 10,
  lateralOffset: 320,
  alongOffset: 90,
  arrowTargetMix: 0.75,
  arrowEndLift: 120,
  arrowStopGap: 70,
};

const trainConnections = []; // per train: { arrowGroup, shaft, head }

function makeOrangeArrow() {
  const g = new THREE.Group();
  const mat = new THREE.MeshBasicMaterial({ color: 0xff8a00, transparent: true, opacity: 1.0 });

  const shaftGeom = new THREE.CylinderGeometry(4.6, 4.6, 1, 10, 1, false);
  const shaft = new THREE.Mesh(shaftGeom, mat);
  shaft.position.y = 0.5;
  g.add(shaft);

  const headGeom = new THREE.ConeGeometry(16, 44, 14, 1, false);
  const head = new THREE.Mesh(headGeom, mat);
  head.position.y = 1;
  g.add(head);

  g.visible = false;
  g.renderOrder = 25;

  return { group: g, shaft, head, headLen: 44 };
}

function setMapOverlayVisible(visible){
  EDGE.centers.forEach(m => { if (m) m.visible = !!visible; });
  trainConnections.forEach(c => { if (c?.arrowGroup) c.arrowGroup.visible = !!visible; });
}

const _tmpA = new THREE.Vector3();
const _tmpB = new THREE.Vector3();
const _tmpDir = new THREE.Vector3();
const _tmpQuat = new THREE.Quaternion();
const columnRaycaster = new THREE.Raycaster();
const MAP_UP_LOCAL = new THREE.Vector3(0, 0, 1);
const _tmpWorldUp = new THREE.Vector3();
const _tmpW = new THREE.Vector3();
const _tmpLocal = new THREE.Vector3();
const _tmpQ = new THREE.Quaternion();

function clearEdgeCenters(){
  for (const m of EDGE.centers){
    if (m.parent) m.parent.remove(m);
    m.geometry?.dispose?.();
    m.material?.dispose?.();
  }
  EDGE.centers.length = 0;
}

function clearTrainArrows(){
  for (const c of trainConnections){
    if (c?.arrowGroup?.parent) c.arrowGroup.parent.remove(c.arrowGroup);
    c?.shaft?.geometry?.dispose?.();
    c?.head?.geometry?.dispose?.();
    c?.shaft?.material?.dispose?.();
  }
  trainConnections.length = 0;
}

function buildEdgeCenters(count){
  if (!rootRef || !pathCurve) return;

  clearEdgeCenters();

  const baseMat = new THREE.MeshStandardMaterial({
    color: 0x1f5cff,
    emissive: 0x1336aa,
    emissiveIntensity: 0.55,
    metalness: 0.15,
    roughness: 0.35,
    transparent: true,
    opacity: 0.95,
  });

  const geom = new THREE.CylinderGeometry(EDGE.radius, EDGE.radius, EDGE.height, 10, 1, false);
  geom.rotateX(Math.PI / 2);

  const tan = new THREE.Vector3();
  const right = new THREE.Vector3();

  rootRef.getWorldQuaternion(_tmpQ);
  _tmpWorldUp.copy(MAP_UP_LOCAL).applyQuaternion(_tmpQ).normalize();

  for (let i = 0; i < count; i++){
    const u = (i + 0.5) / count;

    pathCurve.getPointAt(u, _tmpA);
    pathCurve.getTangentAt(u, tan).normalize();

    right.copy(MAP_UP_LOCAL).cross(tan);
    if (right.lengthSq() < 1e-10) right.set(1, 0, 0);
    right.normalize();

    const side = (i % 2 === 0) ? 1 : -1;

    _tmpA.addScaledVector(right, EDGE.lateralOffset * side);
    _tmpA.addScaledVector(tan, EDGE.alongOffset * side);

    _tmpW.copy(_tmpA);
    rootRef.localToWorld(_tmpW);

    const rayOrigin = _tmpW.clone().addScaledVector(_tmpWorldUp, 2500);
    const rayDir = _tmpWorldUp.clone().multiplyScalar(-1);

    columnRaycaster.set(rayOrigin, rayDir);
    const hits = columnRaycaster.intersectObject(rootRef, true);

    let anchorWorld = _tmpW.clone();
    if (hits.length) anchorWorld.copy(hits[0].point);

    _tmpLocal.copy(anchorWorld);
    rootRef.worldToLocal(_tmpLocal);

    const m = new THREE.Mesh(geom, baseMat.clone());
    m.position.copy(_tmpLocal);
    m.renderOrder = 5;
    m.visible = false;
    m.userData.anchorWorld = anchorWorld.clone();

    EDGE.centers.push(m);
    rootRef.add(m);
  }
}

function initTrainConnections(){
  clearTrainArrows();
  if (!rootRef || EDGE.centers.length <= 0) return;

  for (let i = 0; i < trains.length; i++){
    const { group, shaft, head, headLen } = makeOrangeArrow();
    overlayGroup.add(group);
    trainConnections.push({ arrowGroup: group, shaft, head, headLen });
  }
}

function updateConnections(){
  if (!EDGE.centers.length || !trainConnections.length) return;

  for (let i = 0; i < trains.length; i++){
    const c = trainConnections[i];
    const train = trains[i];
    if (!c || !train) continue;

    train.getWorldPosition(_tmpA);
    _tmpA.z += 30;

    let bestIdx = 0;
    let bestD2 = Infinity;

    for (let j = 0; j < EDGE.centers.length; j++){
      const e = EDGE.centers[j];
      if (!e) continue;
      const aw = e.userData.anchorWorld;
      if (!aw) continue;

      const d2 = _tmpA.distanceToSquared(aw);
      if (d2 < bestD2) { bestD2 = d2; bestIdx = j; }
    }

    const edge = EDGE.centers[bestIdx];
    if (!edge) continue;

    const anchorWorld = edge.userData.anchorWorld;
    if (!anchorWorld) continue;

    edge.getWorldPosition(_tmpB);

    const mix = EDGE.arrowTargetMix;
    _tmpB.lerpVectors(anchorWorld, _tmpB, mix);
    _tmpB.addScaledVector(_tmpWorldUp, EDGE.arrowEndLift);

    _tmpDir.copy(_tmpB).sub(_tmpA);
    const fullLen = _tmpDir.length();
    if (fullLen < 1e-6) continue;
    _tmpDir.multiplyScalar(1 / fullLen);

    _tmpQuat.setFromUnitVectors(new THREE.Vector3(0, 1, 0), _tmpDir);

    const arrow = c.arrowGroup;
    arrow.position.copy(_tmpA);
    arrow.quaternion.copy(_tmpQuat);

    const stopGap = EDGE.arrowStopGap;
    const headLen = c.headLen ?? 44;

    const usable = Math.max(40, fullLen - stopGap);
    const shaftLen = Math.max(1, usable - headLen);

    c.shaft.scale.set(1, shaftLen, 1);
    c.shaft.position.y = shaftLen * 0.5;

    c.head.position.y = shaftLen + headLen * 0.5;

    const maxLen = 2600;
    if (usable > maxLen) {
      const k = maxLen / usable;
      c.shaft.scale.y *= k;
      c.shaft.position.y *= k;
      c.head.position.y *= k;
    }
  }
}

// -----------------------------------------------------
// SCENARIOS
// -----------------------------------------------------
const scenario = { map: false, topo: false, shots: false };

function setBtnActive(btn, on){
  btn?.classList.toggle('active', !!on);
}

function applyScenarioLayout(){
  const mapOn = scenario.map;
  const topoOn = scenario.topo;
  const shotsOn = scenario.shots;

  const noOverlap = mapOn && topoOn && shotsOn;
  document.body.classList.toggle('noOverlapHUD', noOverlap);

  setBtnActive(scenarioVizBtn, mapOn);
  setBtnActive(scenarioTopoBtn, topoOn);
  setBtnActive(scenarioShotsBtn, shotsOn);

  renderer.domElement.style.display = mapOn ? 'block' : 'none';

  if (snapshotsHUDEl) snapshotsHUDEl.style.display = shotsOn ? 'block' : 'none';
  if (topologyHUDEl) topologyHUDEl.style.display = topoOn ? 'block' : 'none';

  if (!mapOn && !topoOn && !shotsOn) {
    renderer.domElement.style.display = 'none';
    if (topologyHUDEl) topologyHUDEl.style.display = 'none';
    if (snapshotsHUDEl) snapshotsHUDEl.style.display = 'none';
    document.body.classList.remove('splitMode','soloTopo','soloShots');
    updateHudTopInset();
    return;
  }

  const split = !mapOn && (topoOn || shotsOn);
  document.body.classList.toggle('splitMode', split);
  document.body.classList.remove('soloTopo', 'soloShots');

  if (shotsOn) { renderGraph(); renderDeployGraph(); }
  if (topoOn) renderTopology();

  setMapOverlayVisible(mapOn);
  updateHudTopInset();
}

scenarioVizBtn?.addEventListener('click', () => { scenario.map = !scenario.map; applyScenarioLayout(); });
scenarioTopoBtn?.addEventListener('click', () => { scenario.topo = !scenario.topo; applyScenarioLayout(); });
scenarioShotsBtn?.addEventListener('click', () => { scenario.shots = !scenario.shots; applyScenarioLayout(); });

scenario.map = true;
applyScenarioLayout();

// -----------------------------------------------------
// GRAPH (event-time latency)
// -----------------------------------------------------
const graphCanvas = document.getElementById('graphCanvas');
const gctx = graphCanvas?.getContext('2d');

const Y_MIN = 10;
const Y_MAX = 1e4;
const LOG_MIN = Math.log10(Y_MIN);
const LOG_MAX = Math.log10(Y_MAX);

function resizeGraphCanvasToCSS() {
  if (!graphCanvas) return;
  const rect = graphCanvas.getBoundingClientRect();
  const dpr = Math.min(window.devicePixelRatio || 1, 2);

  graphCanvas.width  = Math.max(1, Math.floor(rect.width  * dpr));
  graphCanvas.height = Math.max(1, Math.floor(rect.height * dpr));

  if (gctx) gctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}

const SUPER = { 1: '¬π', 2: '¬≤', 3: '¬≥', 4: '‚Å¥' };

function drawGraph(points) {
  if (!gctx || !graphCanvas) return;

  const ctx = gctx;
  const rect = graphCanvas.getBoundingClientRect();
  const w = rect.width;
  const h = rect.height;

  const pad = { l: 56, r: 14, t: 14, b: 34 };
  const x0 = pad.l;
  const y0 = pad.t;
  const x1 = w - pad.r;
  const y1 = h - pad.b;

  ctx.clearRect(0, 0, w, h);

  ctx.fillStyle = 'rgba(0,0,0,0.02)';
  ctx.fillRect(0, 0, w, h);

  ctx.strokeStyle = 'rgba(0,0,0,0.18)';
  ctx.strokeRect(0.5, 0.5, w - 1, h - 1);

  ctx.strokeStyle = 'rgba(0,0,0,0.30)';
  ctx.beginPath();
  ctx.moveTo(x0, y0);
  ctx.lineTo(x0, y1);
  ctx.lineTo(x1, y1);
  ctx.stroke();

  const yAt = (v) => {
    const lv = Math.log10(Math.max(v, Y_MIN));
    const t = (lv - LOG_MIN) / (LOG_MAX - LOG_MIN);
    return y0 + (1 - t) * (y1 - y0);
  };

  ctx.font = '11px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
  ctx.fillStyle = 'rgba(0,0,0,0.55)';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';

  [10, 100, 1000, 10000].forEach(v => {
    const y = yAt(v);

    ctx.strokeStyle = 'rgba(0,0,0,0.10)';
    ctx.setLineDash([2, 6]);
    ctx.beginPath();
    ctx.moveTo(x0, y);
    ctx.lineTo(x1, y);
    ctx.stroke();
    ctx.setLineDash([]);

    ctx.strokeStyle = 'rgba(0,0,0,0.35)';
    ctx.beginPath();
    ctx.moveTo(x0 - 5, y);
    ctx.lineTo(x0, y);
    ctx.stroke();

    const expn = Math.round(Math.log10(v));
    ctx.fillText(`10${SUPER[expn]}`, x0 - 8, y);
  });

  const hasData = points.length >= 2;
  const tNowSec = exp.startMs ? ((nowMs() - exp.startMs) / 1000) : 0;
  const tMaxData = hasData ? points[points.length - 1].tSec : 0;
  const tMaxAxis = (exp.running || exp.scrollAfterStop) ? tNowSec : tMaxData;
  const tMin = Math.max(0, tMaxAxis - 150);

  const xAtT = (t) => {
    const tt = (t - tMin) / Math.max(1e-6, (tMaxAxis - tMin));
    return x0 + tt * (x1 - x0);
  };

  ctx.font = '11px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
  ctx.fillStyle = 'rgba(0,0,0,0.55)';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';

  const span = Math.max(0.001, (tMaxAxis - tMin));
  const MAX_TICKS = 10;

  function niceStep(raw){
    const p = Math.pow(10, Math.floor(Math.log10(raw)));
    const n = raw / p;
    if (n <= 1) return 1 * p;
    if (n <= 2) return 2 * p;
    if (n <= 5) return 5 * p;
    return 10 * p;
  }
  const step = niceStep(span / MAX_TICKS);
  let tTick = Math.ceil(tMin / step) * step;

  for (; tTick <= tMaxAxis + 1e-6; tTick += step) {
    const x = xAtT(tTick);

    ctx.strokeStyle = 'rgba(0,0,0,0.10)';
    ctx.setLineDash([2, 6]);
    ctx.beginPath();
    ctx.moveTo(x, y0);
    ctx.lineTo(x, y1);
    ctx.stroke();
    ctx.setLineDash([]);

    ctx.strokeStyle = 'rgba(0,0,0,0.35)';
    ctx.beginPath();
    ctx.moveTo(x, y1);
    ctx.lineTo(x, y1 + 5);
    ctx.stroke();

    const isIntish = Math.abs(step - Math.round(step)) < 1e-6;
    const label = isIntish ? String(Math.round(tTick)) : (step < 1 ? tTick.toFixed(1) : tTick.toFixed(0));
    ctx.fillText(label, x, y1 + 8);
  }

  if (points.length >= 2) {
    const isHolistic = activeConfig.reconfigMode === 'holistic';

    ctx.fillStyle = isHolistic
      ? 'rgba(255, 138, 0, 0.80)'   // ORANGE for holistic
      : 'rgba(115, 190, 110, 0.80)'; // GREEN for incremental
    ctx.beginPath();

    let started = false;
    for (let i = 0; i < points.length; i++) {
      const pt = points[i];
      if (pt.tSec < tMin) continue;
      const x = xAtT(pt.tSec);
      const y = yAt(pt.v) - 16;
      if (!started) { ctx.moveTo(x, y); started = true; }
      else ctx.lineTo(x, y);
    }

    for (let i = points.length - 1; i >= 0; i--) {
      const pt = points[i];
      if (pt.tSec < tMin) continue;
      const x = xAtT(pt.tSec);
      const y = yAt(pt.v) + 16;
      ctx.lineTo(x, y);
    }

    ctx.closePath();
    ctx.fill();
  }

  ctx.fillStyle = 'rgba(0,0,0,0.70)';
  ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'alphabetic';
  ctx.fillText('runtime (sec.)', (x0 + x1) / 2, h - 10);

  ctx.save();
  ctx.translate(18, (y0 + y1) / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText('event-time latency', 0, 0);
  ctx.restore();

  ctx.textAlign = 'left';
  ctx.fillStyle = 'rgba(0,0,0,0.55)';
  const status = exp.running ? (exp.frozen ? 'RUNNING (graph frozen)' : 'RUNNING') : 'STOPPED';
  ctx.fillText(status, x0 + 6, y0 + 12);

  ctx.textAlign = 'right';
  const rt = exp.running ? ((nowMs() - exp.startMs)/1000) : ((exp.stopMs - exp.startMs)/1000);
  const rtSafe = Number.isFinite(rt) ? rt : 0;
  ctx.fillText(`${rtSafe.toFixed(1)}s`, x1 - 6, y0 + 12);
}

function renderGraph(){
  resizeGraphCanvasToCSS();
  drawGraph(exp.points);
}

// -----------------------------------------------------
// DEPLOYMENT LATENCY (static stacked single column)
//   ‚úÖ Incremental stays GREEN with 12 / 6.1
//   ‚úÖ Holistic becomes ORANGE with 20 overall and 11 on optimization part
// -----------------------------------------------------
function resizeDeployCanvasToCSS() {
  if (!deployCanvas) return;
  const rect = deployCanvas.getBoundingClientRect();
  const dpr = Math.min(window.devicePixelRatio || 1, 2);

  deployCanvas.width  = Math.max(1, Math.floor(rect.width  * dpr));
  deployCanvas.height = Math.max(1, Math.floor(rect.height * dpr));

  if (dctx) dctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function drawDeploymentLatencyStatic(){
  if (!dctx || !deployCanvas) return;

  const ctx = dctx;
  const rect = deployCanvas.getBoundingClientRect();
  const w = rect.width;
  const h = rect.height;

  // --- choose theme by reconfiguration mode ---
  const isHolistic = (activeConfig?.reconfigMode === 'holistic');

  // Incremental: keep exactly as before
  // Holistic: overall=20, optimization number=11, orange color
  const DEPLOY = isHolistic ? 10.9 : 6.4; // bottom segment number stays 6.1 in both modes
  const OPT_TOTAL = isHolistic ? 20.0 : 12.0;  // overall top
  const OPT_LABEL = isHolistic ? '20' : '12';  // blue label above column
  const BAR_COLOR = isHolistic ? '#ff8a00' : '#66c56b'; // orange vs green

  const Y_MIN2 = 1;
  const Y_MAX2 = 1e3;
  const LOG_MIN2 = Math.log10(Y_MIN2);
  const LOG_MAX2 = Math.log10(Y_MAX2);

  const pad = { l: 56, r: 14, t: 14, b: 36 };
  const x0 = pad.l;
  const y0 = pad.t;
  const x1 = w - pad.r;
  const y1 = h - pad.b;

  ctx.clearRect(0, 0, w, h);

  ctx.fillStyle = 'rgba(0,0,0,0.02)';
  ctx.fillRect(0, 0, w, h);

  ctx.strokeStyle = 'rgba(0,0,0,0.18)';
  ctx.strokeRect(0.5, 0.5, w - 1, h - 1);

  // axes
  ctx.strokeStyle = 'rgba(0,0,0,0.30)';
  ctx.beginPath();
  ctx.moveTo(x0, y0);
  ctx.lineTo(x0, y1);
  ctx.lineTo(x1, y1);
  ctx.stroke();

  const yAt = (v) => {
    const lv = Math.log10(Math.max(v, Y_MIN2));
    const t = (lv - LOG_MIN2) / (LOG_MAX2 - LOG_MIN2);
    return y0 + (1 - t) * (y1 - y0);
  };

  const SUPER2 = { 0: '‚Å∞', 1: '¬π', 2: '¬≤', 3: '¬≥' };
  ctx.font = '11px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
  ctx.fillStyle = 'rgba(0,0,0,0.55)';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';

  [1, 10, 100, 1000].forEach(v => {
    const y = yAt(v);

    ctx.strokeStyle = 'rgba(0,0,0,0.10)';
    ctx.setLineDash([2, 6]);
    ctx.beginPath();
    ctx.moveTo(x0, y);
    ctx.lineTo(x1, y);
    ctx.stroke();
    ctx.setLineDash([]);

    ctx.strokeStyle = 'rgba(0,0,0,0.35)';
    ctx.beginPath();
    ctx.moveTo(x0 - 5, y);
    ctx.lineTo(x0, y);
    ctx.stroke();

    const expn = Math.round(Math.log10(v));
    ctx.fillText(`10${SUPER2[expn] ?? ''}`, x0 - 8, y);
  });

  // x single tick ‚Äú2‚Äù
  const cx = (x0 + x1) / 2;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.fillStyle = 'rgba(0,0,0,0.55)';
  ctx.fillText('2', cx, y1 + 8);

  // single column geometry
  const barW = Math.min(86, Math.max(58, (x1 - x0) * 0.20));
  const bx0 = cx - barW / 2;

  const yBase = yAt(1);
  const yDeploy = yAt(DEPLOY);
  const yTop = yAt(OPT_TOTAL);

  // bottom: Deployment (solid)
  ctx.save();
  ctx.fillStyle = BAR_COLOR;
  ctx.strokeStyle = 'rgba(0,0,0,0.85)';
  ctx.lineWidth = 3;

  ctx.beginPath();
  ctx.rect(bx0, yDeploy, barW, yBase - yDeploy);
  ctx.fill();
  ctx.stroke();

  // top: Optimization (hatched)
  ctx.beginPath();
  ctx.rect(bx0, yTop, barW, yDeploy - yTop);
  ctx.fillStyle = BAR_COLOR;
  ctx.fill();
  ctx.stroke();

  ctx.save();
  ctx.beginPath();
  ctx.rect(bx0, yTop, barW, yDeploy - yTop);
  ctx.clip();

  ctx.strokeStyle = 'rgba(0,0,0,0.85)';
  ctx.lineWidth = 2;
  const step = 10;
  for (let x = bx0 - (yBase); x < bx0 + barW + (yBase); x += step) {
    ctx.beginPath();
    ctx.moveTo(x, yBase);
    ctx.lineTo(x + (yBase - y0), y0);
    ctx.stroke();
  }
  ctx.restore();

  // white vertical number in deployment segment (smaller)
  function verticalLabel(text, yMid){
    ctx.save();
    ctx.translate(cx, yMid);
    ctx.rotate(-Math.PI / 2);
    ctx.font = '900 22px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, 0, 0);
    ctx.restore();
  }
  verticalLabel(isHolistic ? '10.4' : '6.1', (yBase + yDeploy) / 2);

  // blue number above (smaller) -> 12 for incremental, 11 for holistic
  ctx.save();
  ctx.font = '900 30px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
  ctx.fillStyle = '#123cff';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'bottom';
  ctx.fillText(OPT_LABEL, cx, yTop - 6);
  ctx.restore();

  // y axis label (deployment-latency)
  ctx.save();
  ctx.translate(18, (y0 + y1) / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
  ctx.fillStyle = 'rgba(0,0,0,0.70)';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'alphabetic';
  ctx.fillText('deployment-latency (s)', 0, 0);
  ctx.restore();

  // legend (top-right)
  const lx = x1 - 140;
  const ly = y0 + 8;

  function legendItem(y, label, hatched){
    const sw = 34, sh = 18;
    ctx.save();
    ctx.lineWidth = 3;
    ctx.strokeStyle = 'rgba(0,0,0,0.85)';
    ctx.fillStyle = BAR_COLOR;
    ctx.beginPath();
    ctx.rect(lx, y, sw, sh);
    ctx.fill();
    ctx.stroke();

    if (hatched) {
      ctx.save();
      ctx.beginPath();
      ctx.rect(lx, y, sw, sh);
      ctx.clip();
      ctx.strokeStyle = 'rgba(0,0,0,0.85)';
      ctx.lineWidth = 2;
      for (let x = lx - 20; x < lx + sw + 20; x += 8) {
        ctx.beginPath();
        ctx.moveTo(x, y + sh);
        ctx.lineTo(x + sh + 20, y - 20);
        ctx.stroke();
      }
      ctx.restore();
    }

    ctx.font = '800 12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
    ctx.fillStyle = 'rgba(0,0,0,0.85)';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    ctx.fillText(label, lx + sw + 10, y + sh / 2);
    ctx.restore();
  }

  legendItem(ly, 'Optimization', true);
  legendItem(ly + 26, 'Deployment', false);

  ctx.restore();
}

function renderDeployGraph(){
  resizeDeployCanvasToCSS();
  drawDeploymentLatencyStatic();
}

// -----------------------------------------------------
// TOPOLOGY GRAPH (placeholder)
// -----------------------------------------------------
const topoCanvas = document.getElementById('topologyCanvas');
const tctx = topoCanvas?.getContext('2d');

function resizeTopoCanvasToCSS() {
  if (!topoCanvas) return;
  const rect = topoCanvas.getBoundingClientRect();
  const dpr = Math.min(window.devicePixelRatio || 1, 2);

  topoCanvas.width  = Math.max(1, Math.floor(rect.width  * dpr));
  topoCanvas.height = Math.max(1, Math.floor(rect.height * dpr));

  if (tctx) tctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function autoFit(ctx, w, h, DW, DH, drawFn) {
  const pad = 18;

  const sx = (w - pad * 2) / DW;
  const sy = (h - pad * 2) / DH;
  const fit = Math.min(sx, sy);

  const s = Math.min(fit * 1.05, 1.10);

  ctx.save();
  ctx.translate((w - DW * s) / 2, (h - DH * s) / 2);
  ctx.scale(s, s);
  drawFn();
  ctx.restore();
}

function drawRectNode(ctx, x, y, label, opts = {}) {
  const ww = opts.w ?? 74;
  const hh = opts.h ?? 34;
  const rr = opts.r ?? 10;
  const stroke = opts.stroke ?? '#243cff';
  const fill = opts.fill ?? 'rgba(255,255,255,0.85)';

  const x0 = x - ww / 2;
  const y0 = y - hh / 2;

  ctx.save();
  ctx.lineWidth = 3;
  ctx.strokeStyle = stroke;
  ctx.fillStyle = fill;

  ctx.beginPath();
  const r = Math.min(rr, ww / 2, hh / 2);
  ctx.moveTo(x0 + r, y0);
  ctx.arcTo(x0 + ww, y0,      x0 + ww, y0 + hh, r);
  ctx.arcTo(x0 + ww, y0 + hh, x0,      y0 + hh, r);
  ctx.arcTo(x0,      y0 + hh, x0,      y0,      r);
  ctx.arcTo(x0,      y0,      x0 + ww, y0,      r);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  ctx.fillStyle = '#111';
  ctx.font = '700 13px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(label, x, y);

  ctx.restore();
}

function drawArrow(ctx, x1, y1, x2, y2, color = '#243cff', w = 3) {
  const head = 12;
  const dx = x2 - x1;
  const dy = y2 - y1;
  const a = Math.atan2(dy, dx);

  ctx.save();
  ctx.strokeStyle = color;
  ctx.fillStyle = color;
  ctx.lineWidth = w;
  ctx.lineCap = 'round';

  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(x2, y2);
  ctx.lineTo(x2 - head * Math.cos(a - Math.PI/7), y2 - head * Math.sin(a - Math.PI/7));
  ctx.lineTo(x2 - head * Math.cos(a + Math.PI/7), y2 - head * Math.sin(a + Math.PI/7));
  ctx.closePath();
  ctx.fill();

  ctx.restore();
}

function drawTopologyPlaceholder() {
  if (!tctx || !topoCanvas) return;

  const ctx = tctx;
  const rect = topoCanvas.getBoundingClientRect();
  const W = rect.width;
  const H = rect.height;

  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = 'rgba(0,0,0,0.01)';
  ctx.fillRect(0, 0, W, H);

  // -------- STATIC SETTINGS --------
  const M = 4;  // MN1..MN4
  const F = 8;  // FN1..FN8
  // --------------------------------

  function drawArrowOffset(x1, y1, x2, y2, color, w, offsetPx = 0) {
    const dx = x2 - x1, dy = y2 - y1;
    const len = Math.hypot(dx, dy) || 1;
    const nx = -dy / len, ny = dx / len;
    drawArrow(ctx, x1 + nx * offsetPx, y1 + ny * offsetPx, x2 + nx * offsetPx, y2 + ny * offsetPx, color, w);
  }

  const DW = 860;
  const DH = 420;

  autoFit(ctx, W, H, DW, DH, () => {
    const cx = DW * 0.5;

    const nodeH = 34;
    const yGap  = 68;

    const mobile = Array.from({ length: M }, (_, i) => ({ id: `MN${i}`, label: `MN${i+1}`, kind: 'mobile' }));
    const fixed  = Array.from({ length: F }, (_, i) => ({ id: `FN${i}`, label: `FN${i+1}`, kind: 'fixed' }));

    const layers = [mobile, fixed];

    let prev = fixed.map(n => ({ ...n }));
    let level = 0;
    while (prev.length > 1) {
      const next = [];
      for (let i = 0; i < prev.length; i += 2) {
        const left = prev[i];
        const right = prev[i + 1];
        const id = `N${level}_${Math.floor(i / 2)}`;
        next.push({
          id,
          label: id,
          kind: 'internal',
          children: right ? [left.id, right.id] : [left.id]
        });
      }
      layers.push(next);
      prev = next.map(n => ({ ...n }));
      level++;
    }

    const baseY = DH - 50;
    const pos = new Map();

    const maxCount = Math.max(1, ...layers.map(L => L.length || 1));
    const spacing = Math.min(130, Math.max(78, (DW - 120) / Math.max(1, (maxCount - 1))));

    function layerXs(count) {
      const totalW = (count - 1) * spacing;
      const start = cx - totalW / 2;
      return Array.from({ length: count }, (_, i) => start + i * spacing);
    }

    {
      const y = baseY - 1 * (nodeH + yGap);
      const xs = layerXs(fixed.length);
      for (let i = 0; i < fixed.length; i++) pos.set(fixed[i].id, { x: xs[i], y });
    }

    {
      const y = baseY - 0 * (nodeH + yGap);
      for (let i = 0; i < mobile.length; i++) {
        const fnPos = pos.get(`FN${i}`);
        const x = fnPos ? fnPos.x : (cx + (i - (mobile.length-1)/2) * spacing);
        pos.set(mobile[i].id, { x, y });
      }
    }

    for (let li = 2; li < layers.length; li++) {
      const L = layers[li];
      const y = baseY - li * (nodeH + yGap);
      const xs = layerXs(L.length);
      for (let i = 0; i < L.length; i++) pos.set(L[i].id, { x: xs[i], y });
    }

    for (let i = 0; i < M; i++) {
      const fnA = pos.get(`FN${2 * i}`);
      const fnB = pos.get(`FN${2 * i + 1}`);
      if (!fnA || !fnB) continue;

      const mn = pos.get(`MN${i}`);
      if (!mn) continue;

      mn.x = (fnA.x + fnB.x) * 0.5;
    }

    const NODE_H = 34;
    const EDGE_GAP = 8;

    const topOf = (id) => {
      const p = pos.get(id);
      return { x: p.x, y: p.y - (NODE_H / 2 + EDGE_GAP) };
    };

    const bottomOf = (id) => {
      const p = pos.get(id);
      return { x: p.x, y: p.y + (NODE_H / 2 + EDGE_GAP) };
    };

    for (let li = 2; li < layers.length; li++) {
      for (const parent of layers[li]) {
        const kids = parent.children || [];
        kids.forEach((kidId, k) => {
          const a = topOf(kidId);
          const b = bottomOf(parent.id);
          const off = (kids.length === 1) ? 0 : (k === 0 ? -7 : +7);
          drawArrowOffset(a.x, a.y, b.x, b.y, '#111111', 3, off);
        });
      }
    }

    for (let i = 0; i < M; i++) {
      const mId = `MN${i}`;
      const redFixedIdx = 2 * i;
      const greenFixedIdx = 2 * i + 1;

      if (redFixedIdx < F) {
        const a = topOf(mId);
        const b = bottomOf(`FN${redFixedIdx}`);
        drawArrowOffset(a.x, a.y, b.x, b.y, '#ff2b2b', 3, -8);
      }
      if (greenFixedIdx < F) {
        const a = topOf(mId);
        const b = bottomOf(`FN${greenFixedIdx}`);
        drawArrowOffset(a.x, a.y, b.x, b.y, '#17b34a', 3, +8);
      }
    }

    for (const L of layers) {
      for (const n of L) {
        const p = pos.get(n.id);
        const stroke =
          (n.kind === 'mobile') ? '#ff8a00' :
          (n.kind === 'fixed')  ? '#243cff' :
                                  '#111111';
        drawRectNode(ctx, p.x, p.y, n.label, { stroke });
      }
    }
  });
}

function renderTopology() {
  resizeTopoCanvasToCSS();
  drawTopologyPlaceholder();
}

// -----------------------------------------------------
// SNAPSHOTS LIST + delete
// -----------------------------------------------------
const snapshots = [];
// each item: { kind: 'event'|'deploy', title, dataUrl }

function deleteSnapshotAt(index){
  if (index < 0 || index >= snapshots.length) return;
  snapshots.splice(index, 1);
  renderSnapshotsList();
}

function renderSnapshotsList(){
  if (!snapshotsBoxEl) return;
  snapshotsBoxEl.innerHTML = '';

  if (!snapshots.length){
    const empty = document.createElement('div');
    empty.className = 'small';
    empty.style.opacity = '0.75';
    empty.style.marginTop = '10px';
    empty.textContent = 'No snapshots yet.';
    snapshotsBoxEl.appendChild(empty);
    return;
  }

  // render in pairs: [event, deploy]
  for (let i = 0; i < snapshots.length; i += 2) {
    const a = snapshots[i];
    const b = snapshots[i + 1];

    const row = document.createElement('div');
    row.className = 'shotRow';

    function makeTile(snap, index){
      if (!snap || !snap.dataUrl) return null;

      const tile = document.createElement('div');
      tile.className = 'shotTile';

      const del = document.createElement('button');
      del.className = 'shotTileDel';
      del.type = 'button';
      del.title = 'Delete this graph';
      del.textContent = '√ó';
      del.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        deleteSnapshotAt(index);
        updateHudTopInset();
      });

      const t = document.createElement('div');
      t.className = 'shotTileTitle';
      t.textContent = `${snap.title} ‚Äî ${snap.kind === 'event' ? 'Event-time' : 'Deployment'}`;

      const m = document.createElement('div');
      m.className = 'shotMeta';

      const img = document.createElement('img');
      img.className = 'shotImg';
      img.src = snap.dataUrl;
      img.alt = t.textContent;

      tile.appendChild(del);
      tile.appendChild(t);
      tile.appendChild(m);
      tile.appendChild(img);

      return tile;
    }

    const tileA = makeTile(a, i);
    const tileB = makeTile(b, i + 1);

    if (tileA) row.appendChild(tileA);
    if (tileB) row.appendChild(tileB);

    snapshotsBoxEl.appendChild(row);
  }
}

renderSnapshotsList();

function addSnapshot(){
  // ensure both canvases are current before capturing
  renderGraph();
  renderDeployGraph();

  const c = activeConfig;
  const fixed = Math.max(0, c.totalNodes);
  const title =
    `${c.mobileNodes} mobile / ${fixed} fixed / ` +
    `${msToLabel(c.topoChangeMs)} / ${c.reconfigMode} / ${c.queryMode}`;

  snapshots.unshift(
    {
      kind: 'event',
      title,
      dataUrl: graphCanvas.toDataURL('image/png')
    },
    {
      kind: 'deploy',
      title,
      dataUrl: deployCanvas ? deployCanvas.toDataURL('image/png') : null
    }
  );

  renderSnapshotsList();
  updateHudTopInset();
}

// -----------------------------------------------------
// EXPERIMENT DATA GENERATION
// -----------------------------------------------------
function clampY(v){ return Math.max(Y_MIN, Math.min(Y_MAX, v)); }

function genBaseline(){
  const base = 60;
  const jitter = (Math.random() - 0.5) * base * 0.35;
  const tinySpike = (Math.random() < 0.01) ? Math.random() * 500 : 0;
  return clampY(base + jitter + tinySpike);
}

// -----------------------------------------------------
// EXPERIMENT START/STOP
// -----------------------------------------------------
function startExperiment(){
  const total = clampEven(parseInt(totalNodesEl.value, 10) || 8, 2, 16);
  totalNodesEl.value = String(total);

  const maxMobile = Math.min(total, 8);
  const mobile = clampEven(parseInt(mobileNodesEl.value, 10) || 4, 2, maxMobile);
  mobileNodesEl.value = String(mobile);

  activeConfig = {
    totalNodes: total,
    mobileNodes: mobile,
    topoChangeMs: parseInt(cameraModeEl.value, 10),
    reconfigMode: reconfigModeEl.value,
    queryMode: queryModeEl.value
  };

  setConfigTitleFromActive();
  setDeployTitleFromActive();

  // show graphs when starting
  setLiveGraphsVisible(true);
  setRunStateLabel('running');

  // trains match mobile nodes
  settings.trainCount = activeConfig.mobileNodes;
  syncUI();
  ensureTrainCount(settings.trainCount);

  // edge centers reflect TOTAL nodes
  const edgeCount = Math.max(2, activeConfig.totalNodes);
  buildEdgeCenters(edgeCount);
  initTrainConnections();
  setMapOverlayVisible(scenario.map);

  settings.speedActive = settings.speedUser;

  resetExperimentGraph();
  exp.running = true;
  exp.startMs = nowMs();
  exp.lastTopoEventMs = exp.startMs;
  exp.stopMs = exp.startMs;

  stopBtn.disabled = false;
  applyConfigBtn.textContent = 'Apply (Restart)';

  clearInterval(exp.tickTimer);
  exp.tickTimer = setInterval(() => {
    if (!exp.running) return;

    const tMs = nowMs();
    const tSec = (tMs - exp.startMs) / 1000;

    const sinceTopo = tMs - exp.lastTopoEventMs;
    const topoEvent = sinceTopo >= activeConfig.topoChangeMs;
    if (topoEvent) exp.lastTopoEventMs = tMs;

    if (activeConfig.reconfigMode === 'holistic') {
      const base = genBaseline();

      if (topoEvent && exp.holistic.phase === 'idle') {
        exp.holistic.phase = 'ramping';
        exp.holistic.rampStartMs = tMs;
        exp.holistic.baseAtRampStart = base;
        exp.holistic.jumpTarget = clampY(3500 + Math.random() * 2500);
      }

      if (exp.holistic.phase === 'idle') {
        exp.points.push({ tSec, v: base });
      } else if (exp.holistic.phase === 'ramping') {
        const u = (tMs - exp.holistic.rampStartMs) / exp.holistic.rampDurationMs;
        const uu = Math.min(1, Math.max(0, u));
        const eased = uu * uu * (3 - 2 * uu);

        const v = exp.holistic.baseAtRampStart +
          eased * (exp.holistic.jumpTarget - exp.holistic.baseAtRampStart) +
          (Math.random() - 0.5) * 120;

        exp.points.push({ tSec, v: clampY(v) });

        if (uu >= 1) {
          exp.holistic.phase = 'frozen';
          exp.frozen = true;
        }
      }
    }

    if (activeConfig.reconfigMode === 'incremental') {
      const baseline = genBaseline();
      if (topoEvent) exp.points.push({ tSec, v: clampY(3000) });
      else exp.points.push({ tSec, v: baseline });
    }

    if (exp.points.length > exp.maxPoints) exp.points.splice(0, exp.points.length - exp.maxPoints);

    if (scenario.shots) renderGraph();
  }, 10);

  if (scenario.shots) { renderGraph(); renderDeployGraph(); }
}

function stopExperiment(){
  if (!exp.running) return;

  // ensure we capture before hiding
  if (scenario.shots) { renderGraph(); renderDeployGraph(); }

  exp.running = false;
  exp.stopMs = nowMs();

  clearInterval(exp.tickTimer);
  exp.tickTimer = null;

  exp.scrollAfterStop = false;
  settings.speedActive = 0;

  stopBtn.disabled = true;

  // snapshot first
  addSnapshot();

  // hide graphs after stopping (only snapshots remain)
  setLiveGraphsVisible(false);
  setRunStateLabel(`stopped @ ${((exp.stopMs - exp.startMs)/1000).toFixed(1)}s`);
}

applyConfigBtn.addEventListener('click', startExperiment);
stopBtn.addEventListener('click', stopExperiment);

// -----------------------------------------------------
// CAMERA VIEW HELPER
// -----------------------------------------------------
function setOrbitView(target, distance, yawDeg, elevationDeg) {
  const yaw = THREE.MathUtils.degToRad(yawDeg);
  const elevClampedDeg = THREE.MathUtils.clamp(elevationDeg, -89.5, 89.5);
  const elev = THREE.MathUtils.degToRad(elevClampedDeg);
  const phi = THREE.MathUtils.degToRad(90) - elev;

  const offset = new THREE.Vector3().setFromSphericalCoords(distance, phi, yaw);
  camera.position.copy(target).add(offset);
  camera.lookAt(target);
  controls.target.copy(target);
  controls.update();
}

// -----------------------------------------------------
// RESET (view + graph + trains to start)
// -----------------------------------------------------
function resetRunAndTrainsToStart(){
  exp.running = false;
  exp.frozen = false;
  exp.scrollAfterStop = false;

  clearInterval(exp.tickTimer);
  exp.tickTimer = null;

  exp.points = [];
  exp.lastTopoEventMs = 0;
  exp.startMs = 0;
  exp.stopMs = 0;

  settings.speedActive = 0;

  for (let i = 0; i < trainData.length; i++) trainData[i].u = 0;

  stopBtn.disabled = true;
  applyConfigBtn.textContent = 'Apply (Start)';

  setConfigTitleFromActive();
  setDeployTitleFromActive();
  setRunStateLabel('idle');

  // show graphs again on reset
  setLiveGraphsVisible(true);

  if (scenario.shots) { renderGraph(); renderDeployGraph(); }
}

resetViewBtn?.addEventListener('click', () => {
  setOrbitView(controls.target, INIT.cam.dist, INIT.cam.yaw, INIT.cam.elev);
  resetRunAndTrainsToStart();
});

// -----------------------------------------------------
// TRAIN COUNT / PATH / MODEL HELPERS
// -----------------------------------------------------
// (unchanged from your file)
function scorePolyline(pts) {
  if (!pts || pts.length < 2) return 0;
  let len = 0;
  for (let i = 1; i < pts.length; i++) len += pts[i].distanceTo(pts[i - 1]);
  return len;
}

function extractOrderedCenterlineByGetter(mesh, root, binsCount, getU) {
  root.updateWorldMatrix(true, true);
  mesh.updateWorldMatrix(true, true);

  const pos = mesh.geometry.attributes.position;
  if (!pos) return null;

  const X = new THREE.Matrix4().copy(root.matrixWorld).invert().multiply(mesh.matrixWorld);

  let uMin = Infinity, uMax = -Infinity;
  for (let i = 0; i < pos.count; i++) {
    const u = getU(i);
    if (!Number.isFinite(u)) continue;
    uMin = Math.min(uMin, u);
    uMax = Math.max(uMax, u);
  }
  if (!Number.isFinite(uMin) || !Number.isFinite(uMax) || Math.abs(uMax - uMin) < 1e-9) return null;

  const invRange = 1 / (uMax - uMin);
  const bins = Array.from({ length: binsCount }, () => ({ sum: new THREE.Vector3(), n: 0 }));
  const v = new THREE.Vector3();

  for (let i = 0; i < pos.count; i++) {
    let u = getU(i);
    if (!Number.isFinite(u)) continue;
    u = (u - uMin) * invRange;
    u = Math.min(1, Math.max(0, u));
    const idx = Math.min(binsCount - 1, Math.max(0, Math.floor(u * binsCount)));

    v.set(pos.getX(i), pos.getY(i), pos.getZ(i)).applyMatrix4(X);
    bins[idx].sum.add(v);
    bins[idx].n++;
  }

  const pts = [];
  for (const b of bins) if (b.n) pts.push(b.sum.multiplyScalar(1 / b.n));

  const out = [];
  const EPS = 0.01;
  for (const pp of pts) {
    if (!out.length || out[out.length - 1].distanceTo(pp) > EPS) out.push(pp.clone());
  }

  return out.length >= 2 ? out : null;
}

function extractOrderedCenterlineAutoUV(mesh, root, binsCount = 1500) {
  const uv = mesh.geometry.attributes.uv;
  if (!uv) return null;

  const ptsX = extractOrderedCenterlineByGetter(mesh, root, binsCount, (i) => uv.getX(i));
  const ptsY = extractOrderedCenterlineByGetter(mesh, root, binsCount, (i) => uv.getY(i));

  const lx = scorePolyline(ptsX);
  const ly = scorePolyline(ptsY);

  return (ly > lx) ? ptsY : ptsX;
}

function findTrainPathMesh(root) {
  let best = null;
  root.traverse(o => {
    if (!o.isMesh) return;
    const n = (o.name || '').toLowerCase();
    if (!n.includes('trainpath')) return;
    const v = o.geometry?.attributes?.position?.count ?? 0;
    if (!best || v > (best.geometry?.attributes?.position?.count ?? 0)) best = o;
  });
  return best;
}

function countMeshes(o) { let meshes = 0; o.traverse(x => { if (x.isMesh) meshes++; }); return meshes; }

function findBestTrainContainer(root) {
  const candidates = [];
  root.traverse(o => {
    const n = (o.name || '').toLowerCase();
    if (!n) return;
    if (n === 'train' || n.includes('train')) candidates.push({ o, meshes: countMeshes(o) });
  });
  candidates.sort((a, b) => b.meshes - a.meshes);
  return candidates.length ? candidates[0].o : null;
}

function detectForwardAxisFromBBox(objLocal) {
  const box = new THREE.Box3().setFromObject(objLocal);
  const size = new THREE.Vector3();
  box.getSize(size);

  let axis = new THREE.Vector3(1, 0, 0);
  if (size.y > size.x && size.y > size.z) axis.set(0, 1, 0);
  else if (size.z > size.x && size.z > size.y) axis.set(0, 0, 1);
  return axis;
}

function rebuildPrototypeAndHideOriginal() {
  if (!rootRef || !rawTrainRef) return;

  const baked = rawTrainRef.clone(true);

  const bakedMatrix = new THREE.Matrix4()
    .copy(rootRef.matrixWorld).invert()
    .multiply(rawTrainRef.matrixWorld);

  baked.matrixAutoUpdate = false;
  baked.matrix.copy(bakedMatrix);
  baked.matrix.decompose(baked.position, baked.quaternion, baked.scale);
  baked.matrixAutoUpdate = true;
  baked.updateWorldMatrix(true, true);

  baked.position.set(0, 0, 0);
  baked.updateWorldMatrix(true, true);

  const forwardAxis = detectForwardAxisFromBBox(baked).normalize();
  modelFixedQ.setFromUnitVectors(forwardAxis, new THREE.Vector3(0, 0, 1));

  trainMeshPrototype = new THREE.Object3D();
  trainMeshPrototype.add(baked);

  rawTrainRef.visible = false;
  rawTrainRef.traverse(o => { o.visible = false; });
}

function makeTrainInstance() {
  const rig = new THREE.Object3D();
  const visual = new THREE.Object3D();
  rig.add(visual);
  rig.userData.visual = visual;

  if (trainMeshPrototype) visual.add(trainMeshPrototype.clone(true));
  return rig;
}

function normalized01(x) {
  x = x % 1;
  return x < 0 ? x + 1 : x;
}

function sortUs() {
  return trainData
    .map((d, idx) => ({ u: normalized01(d.u), idx }))
    .sort((a, b) => a.u - b.u);
}

function findLargestGapMidpoint() {
  if (trainData.length === 0) return 0;

  const arr = sortUs();
  if (arr.length === 1) return normalized01(arr[0].u + 0.5);

  let bestGap = -1;
  let bestMid = 0;

  for (let i = 0; i < arr.length; i++) {
    const a = arr[i].u;
    const b = (i === arr.length - 1) ? (arr[0].u + 1) : arr[i + 1].u;
    const gap = b - a;
    if (gap > bestGap) {
      bestGap = gap;
      bestMid = a + gap * 0.5;
    }
  }
  return normalized01(bestMid);
}

function addOneTrainInLargestGap() {
  if (!rootRef || !pathCurve || !trainMeshPrototype) return;

  const rig = makeTrainInstance();
  rootRef.add(rig);
  trains.push(rig);

  const uNew = findLargestGapMidpoint();
  trainData.push({ u: uNew });
}

function ensureTrainCount(targetCount) {
  while (trains.length < targetCount) addOneTrainInLargestGap();

  while (trains.length > targetCount) {
    const train = trains.pop();
    train?.parent?.remove(train);
    trainData.pop();
  }
}

function buildVisiblePath(curve){
  if (pathMesh && pathMesh.parent){
    pathMesh.parent.remove(pathMesh);
    pathMesh.geometry?.dispose?.();
    pathMesh.material?.dispose?.();
    pathMesh = null;
  }

  const radius = 6;
  const tubularSegments = 600;
  const radialSegments = 8;
  const closed = false;

  const geom = new THREE.TubeGeometry(curve, tubularSegments, radius, radialSegments, closed);

  const mat = new THREE.MeshBasicMaterial({
    color: 0xff2bd6,
    transparent: true,
    opacity: 0.70,
    depthTest: true,
    depthWrite: false
  });

  pathMesh = new THREE.Mesh(geom, mat);
  pathMesh.position.z -= 10;
  pathMesh.renderOrder = -10;
  pathMesh.material.depthTest = true;
  pathMesh.material.depthWrite = false;

  return pathMesh;
}

// -----------------------------------------------------
// LOAD
// -----------------------------------------------------
const dracoLoader = new DRACOLoader();
dracoLoader.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/libs/draco/');
const loader = new GLTFLoader();
loader.setDRACOLoader(dracoLoader);

loader.load(MODEL_URL, (gltf) => {
  rootRef = gltf.scene;
  scene.add(rootRef);

  controls.target.copy(INIT.target);
  controls.update();

  rootRef.position.copy(INIT.modelPos);
  rootRef.updateWorldMatrix(true, true);

  setOrbitView(controls.target, INIT.cam.dist, INIT.cam.yaw, INIT.cam.elev);

  const trainPathMeshRef = findTrainPathMesh(rootRef);
  if (!trainPathMeshRef) return;

  trainPathMeshRef.visible = false;

  const pts = extractOrderedCenterlineAutoUV(trainPathMeshRef, rootRef, 1500);
  if (!pts) return;

  pathCurve = new THREE.CatmullRomCurve3(pts, false, 'centripetal');
  rootRef.add(buildVisiblePath(pathCurve));

  rawTrainRef = findBestTrainContainer(rootRef);
  if (!rawTrainRef) return;

  rebuildPrototypeAndHideOriginal();

  ensureTrainCount(settings.trainCount);
  for (let i=0;i<trainData.length;i++) trainData[i].u = i / Math.max(1, trainData.length);

  const edgeCount = Math.max(2, activeConfig.totalNodes);
  buildEdgeCenters(edgeCount);
  initTrainConnections();

  setMapOverlayVisible(scenario.map);
});

// -----------------------------------------------------
// ANIMATE
// -----------------------------------------------------
const clock = new THREE.Clock();

const worldUp = new THREE.Vector3(0, 1, 0);
const p = new THREE.Vector3();
const t0 = new THREE.Vector3();
const t1 = new THREE.Vector3();
const fwd = new THREE.Vector3();
const right = new THREE.Vector3();
const up2 = new THREE.Vector3();
const basisM = new THREE.Matrix4();
const targetQ = new THREE.Quaternion();

function animate() {
  const dt = Math.min(clock.getDelta(), 0.05);

  if (pathCurve && trains.length) {
    for (let i = 0; i < trains.length; i++) {
      const rig = trains[i];
      const visual = rig.userData.visual;
      const d = trainData[i];

      d.u = (d.u + dt * settings.speedActive) % 1;

      pathCurve.getPointAt(d.u, p);
      rig.position.copy(p);
      rig.position.z -= 10;

      pathCurve.getTangentAt(d.u, t0);
      pathCurve.getTangentAt((d.u + 0.01) % 1, t1);
      fwd.copy(t0).lerp(t1, 0.6).normalize();

      right.copy(worldUp).cross(fwd);
      if (right.lengthSq() < 1e-12) right.set(1, 0, 0);
      right.normalize();

      up2.copy(fwd).cross(right).normalize();

      basisM.makeBasis(right, up2, fwd);
      targetQ.setFromRotationMatrix(basisM);
      targetQ.multiply(modelFixedQ);

      visual.quaternion.slerp(targetQ, 0.15);
    }
  }

  updateConnections();

  controls.update();
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
animate();

// Resize
addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(Math.min(devicePixelRatio, MAX_PIXEL_RATIO));
  renderGraph();
  renderDeployGraph();
  renderTopology();
  updateHudTopInset();
});

// initial canvas render
renderGraph();
renderDeployGraph();
renderTopology();
updateHudTopInset();
</script>
</body>
</html>
